window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "hqm", "modulename": "hqm", "kind": "module", "doc": "<p><img src=\"https://img.shields.io/github/last-commit/alessandrosebastianelli/hybrid_quantum_models?style=flat-square\" alt=\"GitHub last commit\" />\n<img src=\"https://img.shields.io/github/contributors/alessandrosebastianelli/hybrid_quantum_models?style=flat-square\" alt=\"GitHub contributors\" />\n<img src=\"https://img.shields.io/github/issues/alessandrosebastianelli/hybrid_quantum_models?style=flat-square\" alt=\"GitHub issues\" />\n<img src=\"https://img.shields.io/github/issues-pr/alessandrosebastianelli/hybrid_quantum_models?style=flat-square\" alt=\"GitHub pull requests\" /></p>\n\n<h1 id=\"hybrid-quantum-models\">Hybrid Quantum Models</h1>\n\n<p>This library comprises a collection of functions and classes tailored to manage quantum algorithms or circuits that have the capability to interface with two of the most prevalent deep learning libraries, TensorFlow and Torch. Furthermore, the library incorporates a set of predefined hybrid models for tasks such as classification and regression.</p>\n\n<p>To delve deeper into the significance of this library, let's break down its key components and functionalities. Firstly, it offers a diverse set of tools for the manipulation and execution of quantum algorithms. These algorithms harness the principles of quantum mechanics to perform operations that transcend the capacities of classical computers. The library provides an intuitive interface for fully leveraging their potential, ensuring seamless interaction with TensorFlow and Torch, two widely adopted Deep Learning frameworks.</p>\n\n<p>Additionally, the library goes the extra mile by including a set of predefined hybrid models. These models are ready-made solutions for common machine learning tasks such as classification and regression. They seamlessly blend the power of quantum circuits with the traditional deep learning approach, offering developers an efficient way to address various real-world problems.</p>\n\n<p>In summary, this library serves as a versatile bridge between the realms of quantum computing and Deep Learning. It equips developers with the tools to harness the capabilities of quantum algorithms while integrating them effortlessly with Tensorflow and Torch. Furthermore, the inclusion of prebuilt hybrid models simplifies the development process for tasks like classification and regression, ultimately enabling the creation of advanced AI solutions that transcend classical computing limitations.</p>\n\n<p><a class=\"btn btn-success\" href=\"https://alessandrosebastianelli.github.io/hybrid_quantum_models/hqm.html\" target=\"_blank\">Click here to access the documentation</a></p>\n\n<p><strong>!!!This library has been developed and tested mostly for QAI4EO (Quantum Artificial Intelligence for Earth Observation) tasks!!!</strong></p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>This package is stored on <a href=\"https://pypi.org/project/hqm/\">PyPi</a>, you can easily install it using pip</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>pip<span class=\"w\"> </span>install<span class=\"w\"> </span>--upgrade<span class=\"w\"> </span>hqm<span class=\"w\"> </span>--no-deps\n</code></pre>\n</div>\n\n<p>Although certain elements of this library draw from PyTorch or TensorFlow and Pennylane, these packages are not included in the library's prerequisites, and therefore, they will not be automatically installed.</p>\n\n<h2 id=\"usage\">Usage</h2>\n\n<p>The central concept of this package is illustrated in the figure below. In essence, the package generates an embedding of a user-defined quantum circuit (chosen from the available options) into a quantum layer, which is also customizable by the user. This quantum layer can subsequently be converted into a Keras layer or a Torch layer, allowing it to be seamlessly combined with other classical or quantum layers.</p>\n\n<p><img src=\"docs/main-hqm.png\" alt=\"\" />\n<img src=\"main-hqm.png\" alt=\"\" /></p>\n\n<p>A full description of each module can be found in the documentation.</p>\n\n<h2 id=\"how-to-contribute\">How to contribute</h2>\n\n<p><a href=\"https://github.com/alessandrosebastianelli/hybrid_quantum_models/issues/1\">Click here</a></p>\n"}, {"fullname": "hqm.circuits", "modulename": "hqm.circuits", "kind": "module", "doc": "<h1 id=\"quantum-circuits\">Quantum Circuits</h1>\n\n<p>This package contains the implementations for basic, advanced and custom quantum circuits based on PennyLane. The implementation consists of wrappers that encapsulate PennyLane circuits in order to make them compatible with Keras or Pytorch. </p>\n\n<h2 id=\"angle-encoding\">Angle Encoding</h2>\n\n<p>This section relates to circuits that use angle embedding as a feature embedding strategy. This is done by means of the PennyLane operator <em>AngleEmbedding</em>.</p>\n\n<p>This operator encodes $N$ features into the rotation angles of $n$ qubits, where $N\\leq n$. The length of features has to be smaller or equal to the number of qubits. If there are fewer entries in features than rotations, the circuit does not apply the remaining rotation gates.</p>\n\n<p>The following circuits have this operator as the first layer.</p>\n\n<p><a href=\"https://docs.pennylane.ai/en/stable/code/api/pennylane.AngleEmbedding.html\">PennyLane Documentation</a></p>\n\n<h3 id=\"basic-entangler-circuit\">Basic Entangler Circuit</h3>\n\n<p>Layers consisting of one-parameter single-qubit rotations on each qubit, followed by a closed chain or ring of CNOT gates.</p>\n\n<p>The ring of CNOT gates connects every qubit with its neighbor, with the last qubit being considered as a neighbor to the first qubit.</p>\n\n<p><img src=\"../circuits/basic_entangler_circuit.png\" width=\"80%\"/></p>\n\n<p>When using a single wire, the template only applies the single qubit gates in each layer.</p>\n\n<p><a href=\"https://docs.pennylane.ai/en/stable/code/api/pennylane.BasicEntanglerLayers.html\">PennyLane Documentation</a></p>\n\n<h3 id=\"strongly-entangling-circuit\">Strongly Entangling Circuit</h3>\n\n<p>Layers consisting of single qubit rotations and entanglers, inspired by the circuit-centric classifier design arXiv:1804.00633.</p>\n\n<p><img src=\"../circuits/strongly_entangler_circuit.png\" width=\"80%\"/></p>\n\n<p><a href=\"https://docs.pennylane.ai/en/stable/code/api/pennylane.StronglyEntanglingLayers.html\">PennyLane Documentation</a></p>\n\n<h3 id=\"random-circuit\">Random Circuit</h3>\n\n<p>Layers of randomly chosen single qubit rotations and 2-qubit entangling gates, acting on randomly chosen qubits.</p>\n\n<p><img src=\"../circuits/random_circuit.png\" width=\"80%\"/></p>\n\n<p><a href=\"https://docs.pennylane.ai/en/stable/code/api/pennylane.RandomLayers.html\">PennyLane Documentation</a></p>\n\n<h2 id=\"amplitude-encoding\">Amplitude Encoding</h2>\n\n<p>Please refer to the previous section, the circuits are the same but the encoding scheme is different and follows the <a href=\"https://docs.pennylane.ai/en/stable/code/api/pennylane.AmplitudeEmbedding.html\">Amplitude Encoding Strategy</a>.</p>\n\n<h2 id=\"custom-circuits\">Custom Circuits</h2>\n"}, {"fullname": "hqm.circuits.amplitudeencoding", "modulename": "hqm.circuits.amplitudeencoding", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.circuits.amplitudeencoding.BasicEntangledCircuit", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "BasicEntangledCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using a basic entangler\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.amplitudeencoding.BasicEntangledCircuit.__init__", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "BasicEntangledCircuit.__init__", "kind": "function", "doc": "<p>BasicEntangledCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a BasicEntangledCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.amplitudeencoding.BasicEntangledCircuit.circ", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "BasicEntangledCircuit.circ", "kind": "function", "doc": "<p>BasicEntangledCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.amplitudeencoding.StronglyEntangledCircuit", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "StronglyEntangledCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using a strongly entangler\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.amplitudeencoding.StronglyEntangledCircuit.__init__", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "StronglyEntangledCircuit.__init__", "kind": "function", "doc": "<p>StronglyEntangledCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit    </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a StronglyEntangledCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.amplitudeencoding.StronglyEntangledCircuit.circ", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "StronglyEntangledCircuit.circ", "kind": "function", "doc": "<p>StronglyEntangledCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.amplitudeencoding.RandomCircuit", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "RandomCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using a random\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.amplitudeencoding.RandomCircuit.__init__", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "RandomCircuit.__init__", "kind": "function", "doc": "<p>RandomCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a RandomCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.amplitudeencoding.RandomCircuit.circ", "modulename": "hqm.circuits.amplitudeencoding", "qualname": "RandomCircuit.circ", "kind": "function", "doc": "<p>RandomCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.angleencoding", "modulename": "hqm.circuits.angleencoding", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.circuits.angleencoding.BasicEntangledCircuit", "modulename": "hqm.circuits.angleencoding", "qualname": "BasicEntangledCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using a basic entangler\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.angleencoding.BasicEntangledCircuit.__init__", "modulename": "hqm.circuits.angleencoding", "qualname": "BasicEntangledCircuit.__init__", "kind": "function", "doc": "<p>BasicEntangledCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a BasicEntangledCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.angleencoding.BasicEntangledCircuit.circ", "modulename": "hqm.circuits.angleencoding", "qualname": "BasicEntangledCircuit.circ", "kind": "function", "doc": "<p>BasicEntangledCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.angleencoding.StronglyEntangledCircuit", "modulename": "hqm.circuits.angleencoding", "qualname": "StronglyEntangledCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using a strongly entangler\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.angleencoding.StronglyEntangledCircuit.__init__", "modulename": "hqm.circuits.angleencoding", "qualname": "StronglyEntangledCircuit.__init__", "kind": "function", "doc": "<p>StronglyEntangledCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit    </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a StronglyEntangledCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.angleencoding.StronglyEntangledCircuit.circ", "modulename": "hqm.circuits.angleencoding", "qualname": "StronglyEntangledCircuit.circ", "kind": "function", "doc": "<p>StronglyEntangledCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.angleencoding.RandomCircuit", "modulename": "hqm.circuits.angleencoding", "qualname": "RandomCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using a random\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.angleencoding.RandomCircuit.__init__", "modulename": "hqm.circuits.angleencoding", "qualname": "RandomCircuit.__init__", "kind": "function", "doc": "<p>RandomCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a RandomCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.angleencoding.RandomCircuit.circ", "modulename": "hqm.circuits.angleencoding", "qualname": "RandomCircuit.circ", "kind": "function", "doc": "<p>RandomCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.circuit", "modulename": "hqm.circuits.circuit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.circuits.circuit.QuantumCircuit", "modulename": "hqm.circuits.circuit", "qualname": "QuantumCircuit", "kind": "class", "doc": "<p>Basic QuantumCircuit object.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.circuit.QuantumCircuit.__init__", "modulename": "hqm.circuits.circuit", "qualname": "QuantumCircuit.__init__", "kind": "function", "doc": "<p>QuantumCircuit parent class.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a QuantumCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.circuits.customcircuits", "modulename": "hqm.circuits.customcircuits", "kind": "module", "doc": "<p>Work in progress</p>\n"}, {"fullname": "hqm.circuits.customcircuits.BellmanCircuit", "modulename": "hqm.circuits.customcircuits", "qualname": "BellmanCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using the bellman\ncircuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.customcircuits.BellmanCircuit.__init__", "modulename": "hqm.circuits.customcircuits", "qualname": "BellmanCircuit.__init__", "kind": "function", "doc": "<p>BellmanCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n<li>encoding : str <br />\nstring representing the type of input data encoding in quantum circuit, can be 'angle' or 'amplitude'</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a BellmanCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;angle&#39;</span></span>)</span>"}, {"fullname": "hqm.circuits.customcircuits.BellmanCircuit.circ", "modulename": "hqm.circuits.customcircuits", "qualname": "BellmanCircuit.circ", "kind": "function", "doc": "<p>BellmanCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>encoding : str <br />\nstring representing the type of input data encoding in quantum circuit, can be 'angle' or 'amplitude'</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.circuits.customcircuits.RealAmplitudesCircuit", "modulename": "hqm.circuits.customcircuits", "qualname": "RealAmplitudesCircuit", "kind": "class", "doc": "<p>This class implements a torch/keras quantum layer using the real amplitude circuit.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.circuits.customcircuits.RealAmplitudesCircuit.__init__", "modulename": "hqm.circuits.customcircuits", "qualname": "RealAmplitudesCircuit.__init__", "kind": "function", "doc": "<p>RealAmplitudesCircuit constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'  </li>\n<li>encoding : str <br />\nstring representing the type of input data encoding in quantum circuit, can be 'angle' or 'amplitude'</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a RealAmplitudesCircuit object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;angle&#39;</span></span>)</span>"}, {"fullname": "hqm.circuits.customcircuits.RealAmplitudesCircuit.circ", "modulename": "hqm.circuits.customcircuits", "qualname": "RealAmplitudesCircuit.circ", "kind": "function", "doc": "<p>RealAmplitudesCircuit static method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'  </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>encoding : str <br />\nstring representing the type of input data encoding in quantum circuit, can be 'angle' or 'amplitude'</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">encoding</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.classification", "modulename": "hqm.classification", "kind": "module", "doc": "<h1 id=\"classification\">Classification</h1>\n\n<h2 id=\"hmlp-hybrid-multi-layer-perceptron\">hmlp - hybrid multi-layer perceptron</h2>\n\n<p>This package contains several implementations of hybrid multi-layer perceptron.</p>\n\n<h3 id=\"basichybridmlpclassifier\">BasicHybridMLPClassifier</h3>\n\n<p>This class implements a basic hybrid multilayer perceptron for classification purposes. BasicHybridMLPClassifier is composed of quantum layers stacked between two fully connected layers. The size of fully connected layers is set by means of in_dim and ou_dim.</p>\n\n<p><img src=\"../classification/BasicHybridMLPClassifier.png\" width=\"50%\"/></p>\n\n<h3 id=\"multihybridmlpclassifier\">MultiHybridMLPClassifier</h3>\n\n<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for classification purposes. MultiHybridMLPClassifier is composed of several quantum layers stacked between two fully connected layers. The size of fully connected layers is set by means of in_dim and ou_dim.</p>\n\n<p><img src=\"../classification/MultiHybridMLPClassifier.png\" width=\"70%\"/></p>\n\n<h3 id=\"multihybridmultimlpclassifier\">MultiHybridMultiMLPClassifier</h3>\n\n<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for classification purposes. MultiHybridMultiMLPClassifier is composed of several quantum layers stacked between alternating fully connected layers. The size of fully connected layers is set by means of in_dim and ou_dim.</p>\n\n<p><img src=\"../classification/MultiHybridMultiMLPClassifier.png\" width=\"80%\"/></p>\n\n<h2 id=\"hcnns-hybrid-convolutional-neural-networks\">hcnns - hybrid convolutional neural networks</h2>\n\n<h3 id=\"hybrid-lenet-5\">Hybrid LeNet-5</h3>\n\n<p>TO-DO</p>\n"}, {"fullname": "hqm.classification.hcnn", "modulename": "hqm.classification.hcnn", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.classification.hcnn.HybridLeNet5", "modulename": "hqm.classification.hcnn", "qualname": "HybridLeNet5", "kind": "class", "doc": "<p>This class implements a quantum hybrid convolutional neural network based on LeNet-5.\nHybridLeNet5 is composed of classical convlutional block and hybrid quantum MLP.\nThe size of the network output is defined by ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.classification.hcnn.HybridLeNet5.__init__", "modulename": "hqm.classification.hcnn", "qualname": "HybridLeNet5.__init__", "kind": "function", "doc": "<p>HybridLeNet5 constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayer : hqm.layers.basilayer.BasicLayer <br />\nhqm quantum layer to be stacked between two fully connected layers  </li>\n<li>in_shape : tuple <br />\ntuple representing the shape of the input image (channels, widht, height)  </li>\n<li>ou_dim : int <br />\ninteger representing the output size of the hybrid model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a HybridLeNet5 object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qlayer</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">basiclayer</span><span class=\"o\">.</span><span class=\"n\">BasicLayer</span>,</span><span class=\"param\">\t<span class=\"n\">in_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span>,</span><span class=\"param\">\t<span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "hqm.classification.hcnn.HybridLeNet5.forward", "modulename": "hqm.classification.hcnn", "qualname": "HybridLeNet5.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.classification.hmlp", "modulename": "hqm.classification.hmlp", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.classification.hmlp.BasicHybridMLPClassifier", "modulename": "hqm.classification.hmlp", "qualname": "BasicHybridMLPClassifier", "kind": "class", "doc": "<p>This class implements a basic hybrid multilayer perceptron for classification purposes.\nBasicHybridMLPClassifier is composed of quantum layers stacked between two fully connected layers.\nThe size of fully connected layers is set by means of in_dim and ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.classification.hmlp.BasicHybridMLPClassifier.__init__", "modulename": "hqm.classification.hmlp", "qualname": "BasicHybridMLPClassifier.__init__", "kind": "function", "doc": "<p>BasicHybridMLPClassifier constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayer : hqm.layers.basiclayers.BasicLayer <br />\nhqm quantum layer to be stacked between two fully connected layers  </li>\n<li>in_dim : int <br />\ninteger representing the input size for the first fully connected layer  </li>\n<li>ou_dim : int <br />\ninteger representing the output size of the hybrid model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a BasicHybridMLPClassifier object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qlayer</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">basiclayer</span><span class=\"o\">.</span><span class=\"n\">BasicLayer</span>, </span><span class=\"param\"><span class=\"n\">in_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "hqm.classification.hmlp.BasicHybridMLPClassifier.forward", "modulename": "hqm.classification.hmlp", "qualname": "BasicHybridMLPClassifier.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.classification.hmlp.MultiHybridMLPClassifier", "modulename": "hqm.classification.hmlp", "qualname": "MultiHybridMLPClassifier", "kind": "class", "doc": "<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for classification purposes.\nMultiHybridMLPClassifier is composed of several quantum layers stacked between two fully connected layers.\nThe size of fully connected layers is set by means of in_dim and ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.classification.hmlp.MultiHybridMLPClassifier.__init__", "modulename": "hqm.classification.hmlp", "qualname": "MultiHybridMLPClassifier.__init__", "kind": "function", "doc": "<p>MultiHybridMLPClassifier constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayers : list <br />\nlist of hqm quantum layers to be stacked between two fully connected layers  </li>\n<li>in_dim : int <br />\ninteger representing the input size for the first fully connected layer  </li>\n<li>ou_dim : int <br />\ninteger representing the output size of the hybrid model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a MultiHybridMLPClassifier object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qlayers</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">in_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "hqm.classification.hmlp.MultiHybridMLPClassifier.forward", "modulename": "hqm.classification.hmlp", "qualname": "MultiHybridMLPClassifier.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.classification.hmlp.MultiHybridMultiMLPClassifier", "modulename": "hqm.classification.hmlp", "qualname": "MultiHybridMultiMLPClassifier", "kind": "class", "doc": "<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for classification purposes.\nMultiHybridMultiMLPClassifier is composed of several quantum layers stacked between alternating fully connected layers.\nThe size of fully connected layers is set by means of in_dim and ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.classification.hmlp.MultiHybridMultiMLPClassifier.__init__", "modulename": "hqm.classification.hmlp", "qualname": "MultiHybridMultiMLPClassifier.__init__", "kind": "function", "doc": "<p>MultiHybridMultiMLPClassifier constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayers : list <br />\nlist of hqm quantum layers to be stacked between two fully connected layers  </li>\n<li>in_dims: list <br />\nlist of integers representing the input size for the i-th fully connected layer (first value should correspond to size of input data)  </li>\n<li>ou_dim : list <br />\nlist of integers representing the output size for the i-th fully connected layer (last value should correspond to desired output size)  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a MultiHybridMultiMLPClassifier object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qlayers</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">in_dims</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span>)</span>"}, {"fullname": "hqm.classification.hmlp.MultiHybridMultiMLPClassifier.forward", "modulename": "hqm.classification.hmlp", "qualname": "MultiHybridMultiMLPClassifier.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.encoding", "modulename": "hqm.encoding", "kind": "module", "doc": "<h1 id=\"encoding\">Encoding</h1>\n\n<p>TO-DO</p>\n\n<h2 id=\"autoencoders\">Autoencoders</h2>\n\n<p>TO-DO</p>\n\n<h3 id=\"hybrid-autoencoder\">Hybrid Autoencoder</h3>\n\n<p>TO-DO</p>\n\n<h3 id=\"quanvolution-autoencoder\">Quanvolution Autoencoder</h3>\n\n<p>TO-DO</p>\n"}, {"fullname": "hqm.encoding.autoencoders", "modulename": "hqm.encoding.autoencoders", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.encoding.autoencoders.QuanvolutionAutoencoder", "modulename": "hqm.encoding.autoencoders", "qualname": "QuanvolutionAutoencoder", "kind": "class", "doc": "<p>Hybrdid convolutional autoencoder, the encoder is composed of quanvolution layers, the decoder is composed of classical layers.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.encoding.autoencoders.QuanvolutionAutoencoder.__init__", "modulename": "hqm.encoding.autoencoders", "qualname": "QuanvolutionAutoencoder.__init__", "kind": "function", "doc": "<p>QuanvolutionAutoencoder constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qcircuits : list <br />\nlist of QuantumCircuit objects</li>\n<li>in_shape : tuple \ntuple represeting the image shape, (width, height, channels)</li>\n<li>filters : list\nlist containing the number of filters for each quanvolution layer</li>\n<li>kernelsizes: list\nlist containing the kernelsize for each quanvolution layer</li>\n<li>strides: list\nlist containin the stride for each quanvolution layer  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a QuanvolutionAutoencoder object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qcircuits</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">circuits</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">QuantumCircuit</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">in_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">filters</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">kernelsizes</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">strides</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "hqm.encoding.autoencoders.QuanvolutionAutoencoder.encoder_f", "modulename": "hqm.encoding.autoencoders", "qualname": "QuanvolutionAutoencoder.encoder_f", "kind": "function", "doc": "<p>Torch forward method for the encoder</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.encoding.autoencoders.QuanvolutionAutoencoder.decoder_f", "modulename": "hqm.encoding.autoencoders", "qualname": "QuanvolutionAutoencoder.decoder_f", "kind": "function", "doc": "<p>Torch forward method for the decoder</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.encoding.autoencoders.QuanvolutionAutoencoder.forward", "modulename": "hqm.encoding.autoencoders", "qualname": "QuanvolutionAutoencoder.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.encoding.autoencoders.HybridAutoencoder", "modulename": "hqm.encoding.autoencoders", "qualname": "HybridAutoencoder", "kind": "class", "doc": "<p>Hybrdid convolutional autoencoder, the encoder and the decodere are composed of clasical layer, the hidenn space\nis processed by a quantum circuit.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.encoding.autoencoders.HybridAutoencoder.__init__", "modulename": "hqm.encoding.autoencoders", "qualname": "HybridAutoencoder.__init__", "kind": "function", "doc": "<p>QuanvolutionAutoencoder constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayer : hqm.layers.basilayer.BasicLayer <br />\nhqm quantum layer to be stacked between two fully connected layers</li>\n<li>in_shape : tuple \ntuple represeting the image shape, (width, height, channels)</li>\n<li>filters : list\nlist containing the number of filters for each quanvolution layer</li>\n<li>kernelsizes: list\nlist containing the kernelsize for each quanvolution layer</li>\n<li>strides: list\nlist containin the stride for each quanvolution layer  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a QuanvolutionAutoencoder object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qlayer</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">basiclayer</span><span class=\"o\">.</span><span class=\"n\">BasicLayer</span>,</span><span class=\"param\">\t<span class=\"n\">in_shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">filters</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">kernelsizes</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">strides</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span>)</span>"}, {"fullname": "hqm.encoding.autoencoders.HybridAutoencoder.encoder_f", "modulename": "hqm.encoding.autoencoders", "qualname": "HybridAutoencoder.encoder_f", "kind": "function", "doc": "<p>Torch forward method for the encoder</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.encoding.autoencoders.HybridAutoencoder.decoder_f", "modulename": "hqm.encoding.autoencoders", "qualname": "HybridAutoencoder.decoder_f", "kind": "function", "doc": "<p>Torch forward method for the decoder</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.encoding.autoencoders.HybridAutoencoder.forward", "modulename": "hqm.encoding.autoencoders", "qualname": "HybridAutoencoder.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.layers", "modulename": "hqm.layers", "kind": "module", "doc": "<h1 id=\"quantum-layers\">Quantum Layers</h1>\n\n<p>This package contains the implementations for quantum layers, in other words, deep learning layers that contain user-defined quantum circuits.</p>\n\n<h2 id=\"basic-layer\">Basic Layer</h2>\n\n<p>This class serves as a foundational layer without any specific functionalities, primarily designed to facilitate the integration of quantum circuits with Torch or Keras layers. Its main purpose is to establish a bridge between the quantum computing framework and deep learning libraries such as Torch or Keras.</p>\n\n<h2 id=\"quanvolution-layers\">Quanvolution Layers</h2>\n\n<p>Derived from the basic layer, this specific layer is designed to perform quantum convolutions, often referred to as \"quanvolutions.\" It's important to note that, as of now, this layer is exclusively accessible and compatible with Torch-based models.</p>\n\n<p><img src=\"../layers/quanvolution.png\" width=\"80%\"/></p>\n\n<p><strong>Reference</strong>  </p>\n\n<p>Henderson, M., Shakya, S., Pradhan, S., &amp; Cook, T. (2020). Quanvolutional neural networks: powering image recognition with quantum circuits. Quantum Machine Intelligence, 2(1), 2.</p>\n\n<h2 id=\"recurrent-layer\">Recurrent Layer</h2>\n\n<p>Derived from the basic layer, this particular layer serves as an implementation of a recurrent neural layer. It's essential to note that, at the moment, this layer is exclusively accessible and compatible with Torch-based models.</p>\n\n<p><img src=\"../layers/qgru.png\" width=\"80%\"/></p>\n\n<p><strong>Reference</strong>  </p>\n\n<p>A. Ceschini, A. Rosato and M. Panella, \"Hybrid Quantum-Classical Recurrent Neural Networks for Time Series Prediction,\" 2022 International Joint Conference on Neural Networks (IJCNN), Padua, Italy, 2022, pp. 1-8, doi: 10.1109/IJCNN55064.2022.9892441.</p>\n"}, {"fullname": "hqm.layers.basiclayer", "modulename": "hqm.layers.basiclayer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.layers.basiclayer.BasicLayer", "modulename": "hqm.layers.basiclayer", "qualname": "BasicLayer", "kind": "class", "doc": "<p>Basic Quantum Layer</p>\n"}, {"fullname": "hqm.layers.basiclayer.BasicLayer.__init__", "modulename": "hqm.layers.basiclayer", "qualname": "BasicLayer.__init__", "kind": "function", "doc": "<p>BasicLayer constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qcircuit : hqm.circuits.circuit.QuantumCircuit <br />\nQuantumCircuit object to be embedded into the quantum layer</li>\n<li>aiframework : str <br />\nstring representing the AI framework in use, can be 'torch' or 'keras'. This will create <br />\na compatible trainable layer for the framework.   </li>\n</ul>\n\n<h2 id=\"returns\">Returns:    </h2>\n\n<p>Nothing, a BasicLayer object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qcircuit</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">circuits</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">QuantumCircuit</span>, </span><span class=\"param\"><span class=\"n\">aiframework</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span>)</span>"}, {"fullname": "hqm.layers.quanvolution", "modulename": "hqm.layers.quanvolution", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.layers.quanvolution.Quanvolution2D", "modulename": "hqm.layers.quanvolution", "qualname": "Quanvolution2D", "kind": "class", "doc": "<p>Quanvolution2D layer.</p>\n\n<p>Currently supports only Torch.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.layers.quanvolution.Quanvolution2D.__init__", "modulename": "hqm.layers.quanvolution", "qualname": "Quanvolution2D.__init__", "kind": "function", "doc": "<p>Quanvolution2D constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qcircuit : hqm.circuits.circuit.QuantumCircuit <br />\nQuantumCircuit object to be embedded into the quantum layer</li>\n<li>filters : int\nnumber of quanvolution filters</li>\n<li>kernelsize : int\nsize of quanvolution kernel</li>\n<li>stride : int\nstride for quanvolution operation</li>\n<li>padding : str\npadding mode, same of valid</li>\n<li>aiframework : str <br />\nstring representing the AI framework in use, can be 'torch' or 'keras'. This will create <br />\na compatible trainable layer for the framework.</li>\n</ul>\n\n<h2 id=\"returns\">Returns:    </h2>\n\n<p>Nothing, a Quanvolution2D object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qcircuit</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">circuits</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">QuantumCircuit</span>,</span><span class=\"param\">\t<span class=\"n\">filters</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">kernelsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">stride</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">padding</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;same&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">aiframework</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;torch&#39;</span></span>)</span>"}, {"fullname": "hqm.layers.quanvolution.Quanvolution2D.forward", "modulename": "hqm.layers.quanvolution", "qualname": "Quanvolution2D.forward", "kind": "function", "doc": "<p>Torch forward function for quanvolution layer</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>x : torch.Tensor\ninput image or tensor</li>\n</ul>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<ul>\n<li>out : torch.Tensor\nquanvoluted input</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.layers.recurrent", "modulename": "hqm.layers.recurrent", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.layers.recurrent.QGRU", "modulename": "hqm.layers.recurrent", "qualname": "QGRU", "kind": "class", "doc": "<p>Quantum Gradient Recurrent Unit layer.</p>\n\n<p>Currently supports only Torch.</p>\n\n<h6 id=\"reference\">Reference</h6>\n\n<p>A. Ceschini, A. Rosato and M. Panella, \"Hybrid Quantum-Classical Recurrent <br />\nNeural Networks for Time Series Prediction,\" 2022 International Joint Conference <br />\non Neural Networks (IJCNN), Padua, Italy, 2022, pp. 1-8, <br />\ndoi: 10.1109/IJCNN55064.2022.9892441.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.layers.recurrent.QGRU.__init__", "modulename": "hqm.layers.recurrent", "qualname": "QGRU.__init__", "kind": "function", "doc": "<p>QGRU constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qcircuits : list of QuantumCircuit <br />\nlist containing three quantum circuits in this exact order: 1) Quantum Layer Reset, 2) Quantum Layer Update, 3) Quantum Layer Output</li>\n<li>inputsize : int <br />\ninteger representing the number of variable (channels) in the input date</li>\n<li>hiddensize : int <br />\ninteger size representing the recurrent filters</li>\n<li>aiframework : str <br />\nstring representing the AI framework in use, can be 'torch' or 'keras'. This will create <br />\na compatible trainable layer for the framework.</li>\n</ul>\n\n<h2 id=\"returns\">Returns:    </h2>\n\n<p>Nothing, a QGRU object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">qcircuits</span><span class=\"p\">:</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">circuits</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">QuantumCircuit</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">inputsize</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">hiddensize</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">aiframework</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;torch&#39;</span></span>)</span>"}, {"fullname": "hqm.layers.recurrent.QGRU.forward", "modulename": "hqm.layers.recurrent", "qualname": "QGRU.forward", "kind": "function", "doc": "<p>Torch forward function for QGRU layer</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<ul>\n<li>x : torch.Tensor\ninput image or tensor</li>\n</ul>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<ul>\n<li>out : torch.Tensor\nqgru input</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise", "modulename": "hqm.noise", "kind": "module", "doc": "<h1 id=\"quantum-noise-generator\">Quantum Noise Generator</h1>\n\n<p>This package contains the implementations for quantum noise generation.\nThis package is built in collaboration with Artur Miroszewski.</p>\n\n<h2 id=\"gaussianlike\">GaussianLike</h2>\n\n<p>Implementation for Quantum Noise Generator that returns observables withing a gaussian-like distribution.</p>\n"}, {"fullname": "hqm.noise.gaussianlike", "modulename": "hqm.noise.gaussianlike", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.noise.gaussianlike.GaussianLikeNoiseGenerator", "modulename": "hqm.noise.gaussianlike", "qualname": "GaussianLikeNoiseGenerator", "kind": "class", "doc": "<p>This class implements a qantum noise generator, with a distribution is \nclose to Gaussian.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.noise.gaussianlike.GaussianLikeNoiseGenerator.__init__", "modulename": "hqm.noise.gaussianlike", "qualname": "GaussianLikeNoiseGenerator.__init__", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>location : float <br />\nlocation parameter translate the pdf, relative to the standard normal distribution</li>\n<li>scale : float <br />\nscale parameter that stretches the pdf. The greater the magnitude, the greater the stretching. </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'. Recommendent qml.device(\"default.mixed\", wires=1, shots=1000).</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a GaussianLikeNoiseGenerator object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">location</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.noise.gaussianlike.GaussianLikeNoiseGenerator.generate_noise", "modulename": "hqm.noise.gaussianlike", "qualname": "GaussianLikeNoiseGenerator.generate_noise", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator that generates on observable  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<p>Nothing</p>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>n : float\n    gaussianlike quantum noise observable</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.gaussianlike.GaussianLikeNoiseGenerator.generate_noise_array", "modulename": "hqm.noise.gaussianlike", "qualname": "GaussianLikeNoiseGenerator.generate_noise_array", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator that generates a matrix of observables</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<p>shape : tuple\n    shape of the desired maxtrix of observables</p>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>n : float\n    gaussianlike quantum noise matrix of observables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.gaussianlike.GaussianLikeNoiseGenerator.circ", "modulename": "hqm.noise.gaussianlike", "qualname": "GaussianLikeNoiseGenerator.circ", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'   </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.randomcircuit", "modulename": "hqm.noise.randomcircuit", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.noise.randomcircuit.RandomCircuitNoiseGenerator", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCircuitNoiseGenerator", "kind": "class", "doc": "<p>This class implements a quantum noise generator using a random circuit for each sample.</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.noise.randomcircuit.RandomCircuitNoiseGenerator.__init__", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCircuitNoiseGenerator.__init__", "kind": "function", "doc": "<p>RandomCircuitNoiseGenerator constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>location : float <br />\nlocation parameter translate the pdf, relative to the standard normal distribution</li>\n<li>scale : float <br />\nscale parameter that stretches the pdf. The greater the magnitude, the greater the stretching. </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit  </li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'. Recommendent qml.device(\"default.mixed\", wires=1, shots=1000).</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a RandomCircuitNoiseGenerator object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">location</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.noise.randomcircuit.RandomCircuitNoiseGenerator.generate_noise", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCircuitNoiseGenerator.generate_noise", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator that generates on observable  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<p>Nothing</p>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>n : float\n    gaussianlike quantum noise observable</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.randomcircuit.RandomCircuitNoiseGenerator.generate_noise_array", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCircuitNoiseGenerator.generate_noise_array", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator that generates a matrix of observables</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<p>shape : tuple\n    shape of the desired maxtrix of observables</p>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>n : float\n    gaussianlike quantum noise matrix of observables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.randomcircuit.RandomCircuitNoiseGenerator.circ", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCircuitNoiseGenerator.circ", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'   </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.randomcircuit.RandomCZNoiseGenerator", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCZNoiseGenerator", "kind": "class", "doc": "<p>This class implements a quantum noise generator using a random circuit</p>\n", "bases": "typing.Generic[~quantumcircuit]"}, {"fullname": "hqm.noise.randomcircuit.RandomCZNoiseGenerator.__init__", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCZNoiseGenerator.__init__", "kind": "function", "doc": "<p>RandomCircuitNoiseGenerator constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>location : float <br />\nlocation parameter translate the pdf, relative to the standard normal distribution</li>\n<li>scale : float <br />\nscale parameter that stretches the pdf. The greater the magnitude, the greater the stretching. </li>\n<li>n_qubits : int <br />\nnumber of qubits for the quantum circuit  </li>\n<li>n_layers : int <br />\nnumber of layers for the quantum circuit </li>\n<li>n_entangling_layers : int <br />\nnumber of layers with entanglement</li>\n<li>state_id : int\nname of the state to consider</li>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set\nto 'default.qubit'. Recommendent qml.device(\"default.mixed\", wires=1, shots=1000).</li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a RandomCircuitNoiseGenerator object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">location</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_entangling_layers</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">bit_string</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">state_id</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "hqm.noise.randomcircuit.RandomCZNoiseGenerator.generate_noise", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCZNoiseGenerator.generate_noise", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator that generates on observable  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<p>Nothing</p>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>n : float\n    gaussianlike quantum noise observable</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.randomcircuit.RandomCZNoiseGenerator.generate_noise_array", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCZNoiseGenerator.generate_noise_array", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator that generates a matrix of observables</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<p>shape : tuple\n    shape of the desired maxtrix of observables</p>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>n : float\n    gaussianlike quantum noise matrix of observables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"nb\">tuple</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "hqm.noise.randomcircuit.RandomCZNoiseGenerator.circ", "modulename": "hqm.noise.randomcircuit", "qualname": "RandomCZNoiseGenerator.circ", "kind": "function", "doc": "<p>GaussianLikeNoiseGenerator method that implements the quantum circuit.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>dev : qml.device <br />\nPennyLane device on wich run quantum operations (dafault : None). When None it will be set <br />\nto 'default.qubit'   </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>qnode : qml.qnode <br />\nthe actual PennyLane circuit</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dev</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">module</span> <span class=\"s1\">&#39;pennylane.devices&#39;</span> <span class=\"kn\">from</span> <span class=\"s1\">&#39;/Users/asebastianelli/miniforge3/envs/hqm/lib/python3.10/site-packages/pennylane/devices/__init__.py&#39;</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">function</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.regression", "modulename": "hqm.regression", "kind": "module", "doc": "<h1 id=\"regression\">Regression</h1>\n\n<h2 id=\"hmlp-hybrid-multi-layer-perceptron\">hmlp - hybrid multi-layer perceptron</h2>\n\n<p>This package contains several implementations of hybrid multi-layer perceptron.</p>\n\n<h3 id=\"basichybridmlpregressor\">BasicHybridMLPRegressor</h3>\n\n<p>This class implements a basic hybrid multilayer perceptron for regression purposes. BasicHybridMLPRegressor is composed of quantum layers stacked between two fully connected layers. The size of fully connected layers is set by means of in_dim and ou_dim.</p>\n\n<p><img src=\"../regression/BasicHybridMLPRegressor.png\" width=\"50%\"/></p>\n\n<h3 id=\"multihybridmlpregressor\">MultiHybridMLPRegressor</h3>\n\n<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for regression purposes. MultiHybridMLPRegressor is composed of several quantum layers stacked between two fully connected layers. The size of fully connected layers is set by means of in_dim and ou_dim.</p>\n\n<p><img src=\"../regression/MultiHybridMLPRegressor.png\" width=\"70%\"/></p>\n\n<h3 id=\"multihybridmultimlpregressor\">MultiHybridMultiMLPRegressor</h3>\n\n<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for regression purposes. MultiHybridMultiMLPRegressor is composed of several quantum layers stacked between alternating fully connected layers. The size of fully connected layers is set by means of in_dim and ou_dim.</p>\n\n<p><img src=\"../regression/MultiHybridMultiMLPRegressor.png\" width=\"80%\"/></p>\n"}, {"fullname": "hqm.regression.hmlp", "modulename": "hqm.regression.hmlp", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.regression.hmlp.BasicHybridMLPRegressor", "modulename": "hqm.regression.hmlp", "qualname": "BasicHybridMLPRegressor", "kind": "class", "doc": "<p>This class implements a basic hybrid multilayer perceptron for regression purposes.\nBasicHybridMLPRegressor is composed of quantum layers stacked between two fully connected layers.\nThe size of fully connected layers is set by means of in_dim and ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.regression.hmlp.BasicHybridMLPRegressor.__init__", "modulename": "hqm.regression.hmlp", "qualname": "BasicHybridMLPRegressor.__init__", "kind": "function", "doc": "<p>BasicHybridMLPRegressor constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayer : hqm.layers.basiclayer.BasicLayer\nhqm quantum layer to be stacked between two fully connected layers  </li>\n<li>in_dim : int <br />\ninteger representing the input size for the first fully connected layer  </li>\n<li>ou_dim : int <br />\ninteger representing the output size of the hybrid model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a BasicHybridMLPRegressor object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qlayer</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">basiclayer</span><span class=\"o\">.</span><span class=\"n\">BasicLayer</span>, </span><span class=\"param\"><span class=\"n\">in_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "hqm.regression.hmlp.BasicHybridMLPRegressor.forward", "modulename": "hqm.regression.hmlp", "qualname": "BasicHybridMLPRegressor.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.regression.hmlp.MultiHybridMLPRegressor", "modulename": "hqm.regression.hmlp", "qualname": "MultiHybridMLPRegressor", "kind": "class", "doc": "<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for regression purposes.\nMultiHybridMLPRegressor is composed of several quantum layers stacked between two fully connected layers.\nThe size of fully connected layers is set by means of in_dim and ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.regression.hmlp.MultiHybridMLPRegressor.__init__", "modulename": "hqm.regression.hmlp", "qualname": "MultiHybridMLPRegressor.__init__", "kind": "function", "doc": "<p>MultiHybridMLPRegressor constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayer : list <br />\nlist of hqm quantum layers to be stacked between two fully connected layers  </li>\n<li>in_dim : int <br />\ninteger representing the input size for the first fully connected layer  </li>\n<li>ou_dim : int <br />\ninteger representing the output size of the hybrid model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a MultiHybridMLPRegressor object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qlayers</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">in_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span>)</span>"}, {"fullname": "hqm.regression.hmlp.MultiHybridMLPRegressor.forward", "modulename": "hqm.regression.hmlp", "qualname": "MultiHybridMLPRegressor.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>out : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.regression.hmlp.MultiHybridMultiMLPRegressor", "modulename": "hqm.regression.hmlp", "qualname": "MultiHybridMultiMLPRegressor", "kind": "class", "doc": "<p>This class implements a hybrid multilayer perceptron with multiple quantum circuits for regression purposes.\nMultiHybridMultiMLPRegressor is composed of several quantum layers stacked between alternating fully connected layers.\nThe size of fully connected layers is set by means of in_dim and ou_dim.</p>\n", "bases": "torch.nn.modules.module.Module"}, {"fullname": "hqm.regression.hmlp.MultiHybridMultiMLPRegressor.__init__", "modulename": "hqm.regression.hmlp", "qualname": "MultiHybridMultiMLPRegressor.__init__", "kind": "function", "doc": "<p>MultiHybridMultiMLPRegressor constructor.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>qlayers : list <br />\nlist of hqm quantum qlayerss to be stacked between two fully connected layers  </li>\n<li>in_dims: list <br />\nlist of integers representing the input size for the i-th fully connected layer (first value should correspond to size of input data)  </li>\n<li>ou_dim : list <br />\nlist of integers representing the output size for the i-th fully connected layer (last value should correspond to desired output size)  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<p>Nothing, a MultiHybridMLPRegressor object will be created.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">qlayers</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">in_dims</span><span class=\"p\">:</span> <span class=\"nb\">list</span>, </span><span class=\"param\"><span class=\"n\">ou_dim</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span>)</span>"}, {"fullname": "hqm.regression.hmlp.MultiHybridMultiMLPRegressor.forward", "modulename": "hqm.regression.hmlp", "qualname": "MultiHybridMultiMLPRegressor.forward", "kind": "function", "doc": "<p>Torch forward method  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\ninput for the torch model  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>x : torch.Tensor <br />\noutput from the torch model</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">x</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span></span><span class=\"return-annotation\">) -> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">Tensor</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.utils", "modulename": "hqm.utils", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.utils.aiinterface", "modulename": "hqm.utils.aiinterface", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.utils.aiinterface.AIInterface", "modulename": "hqm.utils.aiinterface", "qualname": "AIInterface", "kind": "class", "doc": "<p>This class implements the inteface between quantum circuits implemented in PennyLane and the two most popular DL libraries,\nPytorch and Tensorflow.</p>\n"}, {"fullname": "hqm.utils.aiinterface.AIInterface.network_layer", "modulename": "hqm.utils.aiinterface", "qualname": "AIInterface.network_layer", "kind": "function", "doc": "<p>Static methods that embedd quantum layer into a torch or a keras layer.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>circuit : qml.qnode <br />\npennylane circuit to be embedded   </li>\n<li>weight_shape : dict <br />\nshape of the trainalbe weights, it is derived from hqm.circuits.circuit.QuantumCircuit  </li>\n<li>n_qubits : int <br />\ninteger representing the number of qubits used for the circuit  </li>\n<li>aiframeworkks : str <br />\nstring representing which in wich ai framework the circuit will be embedded, can be 'torch' or 'keras'  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:   </h2>\n\n<ul>\n<li>qlayer : qml.qnn.TorchLayer or qml.qnn.KerasLayer</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">circuit</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">function</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">weight_shape</span><span class=\"p\">:</span> <span class=\"nb\">dict</span>,</span><span class=\"param\">\t<span class=\"n\">n_qubits</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">aiframework</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">pennylane</span><span class=\"o\">.</span><span class=\"n\">qnn</span><span class=\"o\">.</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">TorchLayer</span><span class=\"p\">,</span> <span class=\"n\">pennylane</span><span class=\"o\">.</span><span class=\"n\">qnn</span><span class=\"o\">.</span><span class=\"n\">keras</span><span class=\"o\">.</span><span class=\"n\">KerasLayer</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.utils.printer", "modulename": "hqm.utils.printer", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.utils.printer.Printer", "modulename": "hqm.utils.printer", "qualname": "Printer", "kind": "class", "doc": "<p>This class contains static methods to print quantum circuit information.</p>\n"}, {"fullname": "hqm.utils.printer.Printer.draw_circuit", "modulename": "hqm.utils.printer", "qualname": "Printer.draw_circuit", "kind": "function", "doc": "<p>Draw circuit structure.  </p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>circuit : hqm.circuits.circuit.QuantumCircuit <br />\nhqm circuit to be drawn  </li>\n</ul>\n\n<h2 id=\"return\">Return:  </h2>\n\n<ul>\n<li>str_circ : str <br />\nstring containing circuit structure</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">circuit</span><span class=\"p\">:</span> <span class=\"n\">hqm</span><span class=\"o\">.</span><span class=\"n\">circuits</span><span class=\"o\">.</span><span class=\"n\">circuit</span><span class=\"o\">.</span><span class=\"n\">QuantumCircuit</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "hqm.utils.sizes", "modulename": "hqm.utils.sizes", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "hqm.utils.sizes.size_conv_layer", "modulename": "hqm.utils.sizes", "qualname": "size_conv_layer", "kind": "function", "doc": "<p>Calculate the size of the image after convolution layer</p>\n\n<h2 id=\"parameters\">Parameters:  </h2>\n\n<ul>\n<li>s : int <br />\ninteger represeting the size of one axis of the image  </li>\n<li>kernel_size : int <br />\ninteger represeting the size of the convolutional kernel  </li>\n<li>padding : int <br />\ninteger represeting the padding size  </li>\n<li>stride : int <br />\ninteger representing the stride size  </li>\n</ul>\n\n<h2 id=\"returns\">Returns:  </h2>\n\n<ul>\n<li>size : int <br />\nsize after conv2D and Maxpool</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">kernel_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">padding</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">stride</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();